调试总结


在tinyriscv3段流水的基础上，将执行模块的访存和写回部分所需的数据和处理，分离出来，形成5段流水。
调试时，我们利用的时tinyriscv开源代码所提供的调试命令
1.在修改调试时，为了方便调试，随时检验bug，我们首先将tinyriscv分离成4流水：取指、译指、执行、写回。




4流水修改思路：
将tinyriscv中ex模块所产生的的与寄存器相关的输出数据单独分离出来，打一拍后，再传给下一个写回模块，
reg模块中，写部分是随着时钟上升沿触发的，而改写成4流水后，不需要随着上升沿触发，改为*对任何信号敏感。


5流水修改思路：






debug：思路


4流水
一、首先利用add简单指令测试，进行调试

1.
从3流水变成4流水时。
遇到了问题，debug时，发现在执行某一段bne指令时，指令在执行阶段对jump_flag_o的输出为不定态，而原本3流水在该处输出时，jump_flag_o为低电平，经过代码调试和寻找，发现在bne指令处理时，需要判断两个寄存器的值是否一致，其中1个寄存器的值为不定态，所以无法判断二者是否相等，进而影响了流水线的执行，再观察到reg模块时，其中bne指令执行的第二阶段（译码）中，其中寄存器的值输出为不定态。



如图1：
原因：
发现加法调试，执行的第一条指令（ADDI A27,A0，0） 第二条指令00000093（ADDI A1,A0，0）
而这条指令在我设计的第四阶段执行的是写回，写回到A1寄存器，但发现00208F33（SUB A27,A1，A2）指令正处于译码阶段，需要读寄存器A1和A0，因此这里出现了RAW冲突，因此寄存器产生了不定态。

为了解决这个RAW数据相关问题采用两种方法：


相邻指令出现数据相关：
数据前推:将计算结果从其产生处直接送到其他指令需要处或所有需要的功能单元处，避免流水线暂停。
将id模块的读地址也接入到ex_mem模块中，判断是寄存器1还是寄存器2的读地址与ex阶段的写地址是否一样，若一样，将前推标志置为真，然后输出标志和数据到reg模块中，若前推标志为真，则输出ex模块的内容作为id_ex模块从reg模块所获取的读数据



间隔1条指令出现数据相关：
读写同时条件判断：对于相隔2条指令的指令间的数据相关，可以在回写阶段写入寄存器时做个判断，如果读取的寄存器地址和回写阶段要写入的寄存器地址相同，则直接把回写阶段要写入的数据读出

间隔1条指令出现数据相关：
读写同时条件判断：对于相隔2条指令的指令间的数据相关，可以在回写阶段写入寄存器时做个判断，如果读取的寄存器地址和回写阶段要写入的寄存器地址相同，则直接把回写阶段要写入的数据读出



2.
发现执行到990ns时，我的4流水线遇到了问题，读取的指令与3流水时不同，发现是在43df1a63	BNE A30,A29,...指令执行判断时，指令跳转到了后面执行，通过对A30，A29寄存器的数据流向跟踪，发现是00208f33 	SUB A30，A2，A1 指令写回寄存器时出现了错误，经过仔细检查发现是，由于之前添加的数据前推标志，在前后紧跟着另一个数据前推标志高电平时，并未将另一个数据前推标志置为0。



3.
发现执行到5030ns时，我的流水线指令又一次跳转到了别的地方，没有按顺序执行，，发现是在执行条件跳转指令时，43df1a63	BNE A30,A29,...（1e，1d）处的值不一致，进而找到了00208f33 	SUB A30，A2，A1 处指令，发现时之前注释改过的地方，没有还原。

经过add旧的指令测试，除了jalr指令未通过测试之外，其他RV32I的指令测试都通过

二、利用jalr旧的指令测试调试：








参考资料：蜂鸟e200，tinyriscv，b站视频，csdn博客，参考书：
